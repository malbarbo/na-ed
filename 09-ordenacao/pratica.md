---
title: Ordenação - Prática
urlcolor: Blue
---

@) Partindo do arquivo `ordena_encadeamento.py`, implemente o algoritmo de ordenação por inserção para listas encadeadas. Faça uma versão in-loco e outra que devolve uma nova lista. Qual você achou mais simples?

@) Partindo do arquivo `ordena.py`, implemente uma versão do algoritmo de ordenação por inserção para arranjos em que a parte ordenada fique no final do arranjo.

@) Partindo do arquivo `ordena_encadeamento.py`, implemente o algoritmo de ordenação por seleção para listas encadeadas. Faça uma versão in-loco e outra que devolve uma nova lista. Qual você achou mais simples?

@) Partindo do arquivo `ordena.py`, implemente uma versão do algoritmo de ordenação por seleção para arranjos em que a parte ordenada fique no final do arranjo.

@) Um outro algoritmo de ordenação é a ordenação por flutuação (do inglês, _bubble-sort_). A ideia do algoritmo é percorrer os elementos da sequência diversas vezes e fazer o maior elemento "flutuar" para o final. Isto pode ser feito da seguinte forma: a cada passagem pelos elementos, cada par de elementos adjacentes e comparado e trocando de lugar se o primeiro for maior que o segundo. O algoritmo para quando uma passagem por todos os elementos não gerar nenhum troca (você consegue ver porque o algoritmo funciona?). Implemente o algoritmo de ordenação por flutuação para arranjos e listas encadeadas. Determine a complexidade de tempo, se ele é in-loco e se é estável.

@) O arranjo `[23, 17, 14, 6, 13, 10, 1, 5, 7, 12]` é um heap máximo?

@) Mostre passo a passo a construção de um heap mínimo com os elementos do arranjo `[5, 1, 7, 4, 9, 1, 3, 4, 8, 6]`.

@) Crie um exemplo de arranjo que mostre que a ordenação por heap não é estável.

<!--
@) Shell sort

-->
